@startuml
title Proxy Pattern
namespace HeadFirst.DesignPatterns.Proxy{
    note as ProxyPatternDefind
    <b>代理模式</b>
    为另一个对象提供一个替身或点位符以控制对这个对象的访问

    <b>要点</b>
    * 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。
    * 远程代理管理客户和远程对象之间的交互。
    * 虚拟代理控制访问实例化开销大的对象。
    * 保护代理基于调用者控制对对象的访问。
    * 代理模式有许多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。
    * 代理在结构上类似装饰者，但是目的不同。
    * 装饰者模式为对象加上行为，而代理则是控制访问。
    * 就和其它的包装者一样，代理会造成你的设计中类的数目增加。
    end note

    RealSubject .up.|> ISubject
    Proxy .up.|> ISubject
    Proxy ->RealSubject:通常由Proxy负责创建RealSubject对象
    interface ISubject
    {
        void Request();
    }

    note as ISubjectNote
    Proxy和RealSubject 都实现了ISubject接口，这允许任何客户都可以像处理
    RealSubject对象一样地处理Proxy对象
    end note

    ISubjectNote .. ISubject

    class RealSubject
    {
        + void Request();
    }

    note as RealSubjectNote
    RealSubject通常是真正做事的对象，Proxy会控制对RealSubject的访问
    end note

    RealSubjectNote .left. RealSubject

    class Proxy
    {
        + void Request();
    }

    note as ProxyNote
    创建RealSubject对象，通常由Proxy负责
    Proxy持有ISubject的引用，所以必要时它可以将请求转发给ISubject。
    end note

    ProxyNote .right. Proxy
}
@enduml